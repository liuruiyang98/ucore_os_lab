# Lab1实验报告
计61 柳瑞阳 2016011396

## 练习一：

#### 操作系统镜像文件ucore.img是如何一步一步生成的？

答：运行命令行指令 **make V=**，观察输出可见编译过程如下：  

* 运行编译器对操作系统内核代码进行编译生成重定向执行文件（ **.o** 文件）。需要编译的文件包括：
	* kern/init 文件下的 init.c；
	* kern/libs 文件下的 readline.c，stdio.c；
	* kern/debug 文件下的 kmonitor.c，panic.c；
	* kern/driver 文件下的 clock.c，console.c，intr.c，picirq.c；
	* kern/trap 文件下的 trap.c，trapentry.S，vectors.S；
	* kern/mm 文件下的 pmm.c；
	* libs/ 文件下的 printfmt.c，string.c

　　代码举例如下：

		+ cc kern/debug/panic.c
		i386-elf-gcc -Ikern/debug/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/debug/panic.c -o obj/kern/debug/panic.o

　　其中使用参数意义如下：

　　　　-nostdinc：使编译器不再系统缺省的目录里查找头文件，一般和-I一起使用，明确限定头文件的位置。    
　　　　-fno-builtin：不使用C语言的内建函数而使用自己定义的，例如printf。  
　　　　-Wall：编译时显示所有的警告，由于检查程序错误。  
　　　　-ggdb：此选项将尽可能的生成gdb可以使用的调试信息。  
　　　　-m32：交叉编译选项，生成32位（x86）代码。  
　　　　-gstabs：此选项以stabs格式生成调试信息，但是不包括gdb调试信息。  
　　　　-fno-stack-protector：不使用栈完整性确认（金丝雀）机制，在某些默认打开stack protector的编译器上必须使用，这是因为该机制会调用__stack_chk_fail标准库函数，而在编译操作系统内核时我们不能使用标准库。

* 运行链接器链接重定向文件，将上述生成的 .o 文件链接为 ELF 格式可执行文件 /bin/kernel：

		+ ld bin/kernel
		i386-elf-ld -m elf_i386 -nostdlib -T tools/kernel.ld -o bin/kernel  obj/kern/init/init.o obj/kern/libs/readline.o obj/kern/libs/stdio.o obj/kern/debug/kdebug.o obj/kern/debug/kmonitor.o obj/kern/debug/panic.o obj/kern/driver/clock.o obj/kern/driver/console.o obj/kern/driver/intr.o obj/kern/driver/picirq.o obj/kern/trap/trap.o obj/kern/trap/trapentry.o obj/kern/trap/vectors.o obj/kern/mm/pmm.o  obj/libs/printfmt.o obj/libs/string.o

　　其中使用参数意义如下：  

　　　　-m elf\_i386：交叉编译生成i386平台的代码。  
　　　　-nostdlib：不链接C标准库，防止C标准库使用自带的init函数代替入口函数。  
　　　　-T tools/kernel.ld：使用自编的链接脚本进行代码段、数据段空间的分配，并把ELF可执行文件的入口点设置为函数kern_init。  

* 运行编译器对 Bootloader 代码进行编译生成重定向执行文件（ **.o** 文件）。需要编译的文件包括：
	* boot 文件下的 bootasm.S；
	* boot 文件下的 bootmain.c；

　　代码举例如下：

		+ cc boot/bootasm.S
		i386-elf-gcc -Iboot/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Os -nostdinc -c boot/bootasm.S -o obj/boot/bootasm.o

　　其中使用参数意义同上。  

* 运行编译器和链接器对硬盘主引导扇区进行编译和链接，生成 bin/sign。  

　　代码举例如下：

		+ cc tools/sign.c
		gcc -Itools/ -g -Wall -O2 -c tools/sign.c -o obj/sign/tools/sign.o
		gcc -g -Wall -O2 obj/sign/tools/sign.o -o bin/sign

　　其中使用参数意义如下：  

　　　　-g 保留代码的文字信息，便于调试。  
　　　　-O2：优化优先级选项。  
　　　　-Wall：编译时显示所有的警告，由于检查程序错误。  

* 运行链接器链接Bootloader，生成 bin/bootblock。  

　　代码举例如下：

	+ ld bin/bootblock
	i386-elf-ld -m elf_i386 -nostdlib -N -e start -Ttext 0x7C00 obj/boot/bootasm.o obj/boot/bootmain.o -o obj/bootblock.o

　　其中使用参数意义如下：  
 
　　　　-N：将代码区和数据区设置为可读可写，不对数据区进行页对齐，不链接标准库。  
　　　　-e start：设置入口函数为start。  
　　　　-Ttext 0x7C00：设定代码段的虚拟内存地址为0x7C00，即主引导扇区被读取到内存的地址。这个地址实际是BIOS自动拷贝到的，这里再次进行设定应该是程序中直接寻址需要。  

* 运行 OBJDUMP 和 OBJCOPY 实用工具，导出 Bootloader 的代码段。

　　输出结果举例如下：

	'obj/bootblock.out' size: 500 bytes

* 使用 sign 程序，处理 Bootloader 代码，生成 512 字节的 MBR 扇区镜像。

　　输出结果举例如下：

	build 512 bytes boot sector: 'bin/bootblock' success!

* 运行dd程序，创建ucore.img硬盘镜像。  

　　输出结果举例如下：

	dd if=/dev/zero of=bin/ucore.img count=10000
	10000+0 records in
	10000+0 records out
	5120000 bytes transferred in 0.064835 secs (78969896 bytes/sec)
	dd if=bin/bootblock of=bin/ucore.img conv=notrunc
	1+0 records in
	1+0 records out
	512 bytes transferred in 0.000028 secs (18354561 bytes/sec)
	dd if=bin/kernel of=bin/ucore.img seek=1 conv=notrunc
	154+1 records in
	154+1 records out

　　其中使用参数意义如下：  
 
　　　　if：输入文件。  
　　　　of：输出文件。  
　　　　count：拷贝block的个数。  
　　　　seek：数据拷贝起始block寻址。  
　　　　conv=notrunc：当dd到一个比源文件大的目标文件时，不缩小目标文件。  

　　至此 ucore.img 文件生成完成。

---


#### 一个被系统认为是符合规范的硬盘主引导扇区的特征是什么？

答：通过阅读 **ucore_os_lab/labcodes/lab1/tools/sign.c** 的代码可发现，符合规范的硬盘主引导扇区的特征包括 3 个方面：  

* st.st_size 不能超过 510 字节，即启动代码和硬盘分区表加起来不能超过 510 字节。   
* 主引导扇区大小为 512 字节。   
* 结束标志字，即最后两个字节为 0x55 和 0xAA。

---

<br><br><br>


## 练习二：

#### 准备工作：模仿学堂在线视频进行操作
* 步骤一：在 lab1/Makefile 中新增代码：  

		lab1-mon: $(UCOREIMG)
			$(V)$(TERMINAL) -e "$(QEMU) -S -s -d in_asm -D $(BINDIR)/q.log -monitor stdio -hda $< -serial null"
			$(V)sleep 2
			$(V)$(TERMINAL) -e "gdb -q -x tools/lab1init"
		
	其中修改的第一条指令含义为，新启动一个 gnome 终端并运行 debug 状态的 qemu，并将打印的汇编代码输出到 q.log 文件中。第三条指令含义为初始化 gdb 调试指令。  

* 步骤二：在 lab1/tools/ 中新增文件 lab1init，其内容如下：  

		file bin/kernel
		target remote :1234
		set architecture i8086
		b *0x7c00
		continue
		x /2i $pc  

　　含义为：首先加载 kernel，然后使得 qemu 和 gdb 之间使用网络端口 1234 进行通讯，刚开始 BIOS 进入 8086 的 16 位实模式方式。在地址为 0x7c00（Bootloader第一条指令）处设置断点，然后使得程序运行，然后显示出 PC 寄存器（EIP 指令指针寄存器）处开始的两条指令。

* 步骤三：运行指令 make lab1-mon，观察输出结果；并输入指令 x /10i $pc，观察输出结果。并检验与 lab1/boot/bootasm.S 中代码一致。

<div style="text-align:center;">
	<img src="./实验截图/lab1-练习2-1.png" width="600">
	<img src="./实验截图/lab1-练习2-2.png" width="600">
</div>

---

#### 1. 从CPU加电后的第一条指令开始，单步跟踪BIOS的运行。
* 步骤一：在 lab1/Makefile 中新增代码：  

		lab1-liuruiyang-debug: $(UCOREIMG)
		$(V)$(TERMINAL) -e "$(QEMU) -S -s -d in_asm -D $(BINDIR)/q.log -monitor stdio -hda $< -serial null"
		$(V)sleep 2
		$(V)$(TERMINAL) -e "gdb -q -x tools/lab1liuruiyangdebug" 

* 步骤二：在 lab1/tools/ 中新增文件 lab1liuruiyangdebug，其内容如下：  

		file bin/kernel
		target remote :1234
		set architecture i8086

* 步骤三：运行指令 make lab1-liuruiyang-debug，进行实验。可见在 gdb 调试中，访问 \$PC 寄存器时，其值为 0xfff0，说明其并未考虑 CS 寄存器的偏移，因为 gdb 调试设置模拟的CPU架构为 i8086，其为 16 位模式，无法找到正确的地址；而在 qemu 调试中，访问 \$PC 寄存器，发现其按照 CS:IP 计算启动地址，地址为 0xfffffff0，可见此时 CPU 初始时处于 32 位实模式，第一条运行的指令为：  

		(qemu) x $pc
		0xfffffff0:  ljmp   $0xf000,$0xe05b

  在 gdb 调试中输入 nexti（单步一条机器指令，不进入函数），实现长跳转，随后依旧在 qemu 调试中观察，此时 CPU 进入16位实模式，此时指令如下所示：

		(qemu) x /10i $pc
		0x000fe05b:  cmpl   $0x0,%cs:0x6c48
		0x000fe062:  jne    0xfd2e1
		0x000fe066:  xor    %dx,%dx
		0x000fe068:  mov    %dx,%ss
		0x000fe06a:  mov    $0x7000,%esp
		0x000fe070:  mov    $0xf3691,%edx
		0x000fe076:  jmp    0xfd165
		0x000fe079:  push   %ebp
		0x000fe07b:  push   %edi
		0x000fe07d:  push   %esi

<div style="text-align:center;">
	<img src="./实验截图/lab1-练习2-3.png" width="600">
	<img src="./实验截图/lab1-练习2-4.png" width="600">
	<img src="./实验截图/lab1-练习2-5.png" width="600">
</div>

#### 2. 在初始化位置0x7c00设置实地址断点,测试断点正常。
* 步骤四：在 gdb 调试中，输入指令 **b \*0x7c00**，再执行 **continue**，最后输入指令 **x /10i $pc**，其和之前的准备练习中观察的结果相同，说明测试断点正常。

<div style="text-align:center;">
	<img src="./实验截图/lab1-练习2-6.png" width="600">
</div>

#### 3. 从0x7c00开始跟踪代码运行,将单步跟踪反汇编得到的代码与bootasm.S和 bootblock.asm进行比较。
* 步骤五：设置宏指令 showstep，使得 pc += 1，并展示当前 pc 寄存器所指的指令。宏指令设置如下：

		define showstep
		nexti
		x/i $pc
		end  

　　经过观察输出，可以发现代码与 lab1/boot/bootasm.S 中代码一致基本相同。虽然有部分指令经过了编译器的优化，但是整体执行的逻辑和顺序依旧保持不变。

<div style="text-align:center;">
	<img src="./实验截图/lab1-练习2-7.png" width="900">
</div>

#### 4. 自己在内核或Bootloader中寻找代码位置，进行断点测试
* 步骤六：在 kern/debug/kdebug.c 中我选择函数 **print_kerninfo** 作为断点，在 gdb 调试中使用命令 **break print_kerninfo** 和 **continue**，发现 PC 停止在 **0x10084c** 处。随后进行断点测试，测试结果如下图：  

<div style="text-align:center;">
	<img src="./实验截图/lab1-练习2-8.png" width="600">
</div>

---

<br><br><br>

## 练习三：