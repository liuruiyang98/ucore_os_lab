# Lab1实验报告
计61 柳瑞阳 2016011396

## 练习一：

#### 操作系统镜像文件ucore.img是如何一步一步生成的？

答：运行命令行指令 **make V=**，观察输出可见编译过程如下：  

* 运行编译器对操作系统内核代码进行编译生成重定向执行文件（ **.o** 文件）。需要编译的文件包括：
	* kern/init 文件下的 init.c；
	* kern/libs 文件下的 readline.c，stdio.c；
	* kern/debug 文件下的 kmonitor.c，panic.c；
	* kern/driver 文件下的 clock.c，console.c，intr.c，picirq.c；
	* kern/trap 文件下的 trap.c，trapentry.S，vectors.S；
	* kern/mm 文件下的 pmm.c；
	* libs/ 文件下的 printfmt.c，string.c

　　代码举例如下：

		+ cc kern/debug/panic.c
		i386-elf-gcc -Ikern/debug/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/debug/panic.c -o obj/kern/debug/panic.o

　　其中使用参数意义如下：

　　　　-nostdinc：使编译器不再系统缺省的目录里查找头文件，一般和-I一起使用，明确限定头文件的位置。    
　　　　-fno-builtin：不使用C语言的内建函数而使用自己定义的，例如printf。  
　　　　-Wall：编译时显示所有的警告，由于检查程序错误。  
　　　　-ggdb：此选项将尽可能的生成gdb可以使用的调试信息。  
　　　　-m32：交叉编译选项，生成32位（x86）代码。  
　　　　-gstabs：此选项以stabs格式生成调试信息，但是不包括gdb调试信息。  
　　　　-fno-stack-protector：不使用栈完整性确认（金丝雀）机制，在某些默认打开stack protector的编译器上必须使用，这是因为该机制会调用__stack_chk_fail标准库函数，而在编译操作系统内核时我们不能使用标准库。

* 运行链接器链接重定向文件，将上述生成的 .o 文件链接为 ELF 格式可执行文件 /bin/kernel：

		+ ld bin/kernel
		i386-elf-ld -m elf_i386 -nostdlib -T tools/kernel.ld -o bin/kernel  obj/kern/init/init.o obj/kern/libs/readline.o obj/kern/libs/stdio.o obj/kern/debug/kdebug.o obj/kern/debug/kmonitor.o obj/kern/debug/panic.o obj/kern/driver/clock.o obj/kern/driver/console.o obj/kern/driver/intr.o obj/kern/driver/picirq.o obj/kern/trap/trap.o obj/kern/trap/trapentry.o obj/kern/trap/vectors.o obj/kern/mm/pmm.o  obj/libs/printfmt.o obj/libs/string.o

　　其中使用参数意义如下：  

　　　　-m elf\_i386：交叉编译生成i386平台的代码。  
　　　　-nostdlib：不链接C标准库，防止C标准库使用自带的init函数代替入口函数。  
　　　　-T tools/kernel.ld：使用自编的链接脚本进行代码段、数据段空间的分配，并把ELF可执行文件的入口点设置为函数kern_init。  

* 运行编译器对 Bootloader 代码进行编译生成重定向执行文件（ **.o** 文件）。需要编译的文件包括：
	* boot 文件下的 bootasm.S；
	* boot 文件下的 bootmain.c；

　　代码举例如下：

		+ cc boot/bootasm.S
		i386-elf-gcc -Iboot/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Os -nostdinc -c boot/bootasm.S -o obj/boot/bootasm.o

　　其中使用参数意义同上。  

* 运行编译器和链接器对硬盘主引导扇区进行编译和链接，生成 bin/sign。  

　　代码举例如下：

		+ cc tools/sign.c
		gcc -Itools/ -g -Wall -O2 -c tools/sign.c -o obj/sign/tools/sign.o
		gcc -g -Wall -O2 obj/sign/tools/sign.o -o bin/sign

　　其中使用参数意义如下：  

　　　　-g 保留代码的文字信息，便于调试。  
　　　　-O2：优化优先级选项。  
　　　　-Wall：编译时显示所有的警告，由于检查程序错误。  

* 运行链接器链接Bootloader，生成 bin/bootblock。  

　　代码举例如下：

	+ ld bin/bootblock
	i386-elf-ld -m elf_i386 -nostdlib -N -e start -Ttext 0x7C00 obj/boot/bootasm.o obj/boot/bootmain.o -o obj/bootblock.o

　　其中使用参数意义如下：  
 
　　　　-N：将代码区和数据区设置为可读可写，不对数据区进行页对齐，不链接标准库。  
　　　　-e start：设置入口函数为start。  
　　　　-Ttext 0x7C00：设定代码段的虚拟内存地址为0x7C00，即主引导扇区被读取到内存的地址。这个地址实际是BIOS自动拷贝到的，这里再次进行设定应该是程序中直接寻址需要。  

* 运行 OBJDUMP 和 OBJCOPY 实用工具，导出 Bootloader 的代码段。

　　输出结果举例如下：

	'obj/bootblock.out' size: 500 bytes

* 使用 sign 程序，处理 Bootloader 代码，生成 512 字节的 MBR 扇区镜像。

　　输出结果举例如下：

	build 512 bytes boot sector: 'bin/bootblock' success!

* 运行dd程序，创建ucore.img硬盘镜像。  

　　输出结果举例如下：

	dd if=/dev/zero of=bin/ucore.img count=10000
	10000+0 records in
	10000+0 records out
	5120000 bytes transferred in 0.064835 secs (78969896 bytes/sec)
	dd if=bin/bootblock of=bin/ucore.img conv=notrunc
	1+0 records in
	1+0 records out
	512 bytes transferred in 0.000028 secs (18354561 bytes/sec)
	dd if=bin/kernel of=bin/ucore.img seek=1 conv=notrunc
	154+1 records in
	154+1 records out

　　其中使用参数意义如下：  
 
　　　　if：输入文件。  
　　　　of：输出文件。  
　　　　count：拷贝block的个数。  
　　　　seek：数据拷贝起始block寻址。  
　　　　conv=notrunc：当dd到一个比源文件大的目标文件时，不缩小目标文件。  

　　至此 ucore.img 文件生成完成。

---


#### 一个被系统认为是符合规范的硬盘主引导扇区的特征是什么？

答：通过阅读 **ucore_os_lab/labcodes/lab1/tools/sign.c** 的代码可发现，符合规范的硬盘主引导扇区的特征包括 3 个方面：  

* st.st_size（文件内容） 不能超过 510 字节，即启动代码和硬盘分区表加起来不能超过 510 字节。   
* 主引导扇区大小为 512 字节。   
* 结束标志字，即最后两个字节为 0x55 和 0xAA。

---

<br><br><br>


## 练习二：

#### 准备工作：模仿学堂在线视频进行操作
* 步骤一：在 lab1/Makefile 中新增代码：  

		lab1-mon: $(UCOREIMG)
			$(V)$(TERMINAL) -e "$(QEMU) -S -s -d in_asm -D $(BINDIR)/q.log -monitor stdio -hda $< -serial null"
			$(V)sleep 2
			$(V)$(TERMINAL) -e "gdb -q -x tools/lab1init"
		
	其中修改的第一条指令含义为，新启动一个 gnome 终端并运行 debug 状态的 qemu，并将打印的汇编代码输出到 q.log 文件中。第三条指令含义为初始化 gdb 调试指令。  

* 步骤二：在 lab1/tools/ 中新增文件 lab1init，其内容如下：  

		file bin/kernel
		target remote :1234
		set architecture i8086
		b *0x7c00
		continue
		x /2i $pc  

　　含义为：首先加载 kernel，然后使得 qemu 和 gdb 之间使用网络端口 1234 进行通讯，刚开始 BIOS 进入 8086 的 16 位实模式方式。在地址为 0x7c00（Bootloader第一条指令）处设置断点，然后使得程序运行，然后显示出 PC 寄存器（EIP 指令指针寄存器）处开始的两条指令。

* 步骤三：运行指令 make lab1-mon，观察输出结果；并输入指令 x /10i $pc，观察输出结果。并检验与 lab1/boot/bootasm.S 中代码一致。

<div style="text-align:center;">
	<img src="./实验截图/lab1-练习2-1.png" width="900">
	<img src="./实验截图/lab1-练习2-2.png" width="900">
</div>

---

#### 1. 从CPU加电后的第一条指令开始，单步跟踪BIOS的运行。
* 步骤一：在 lab1/Makefile 中新增代码：  

		lab1-liuruiyang-debug: $(UCOREIMG)
		$(V)$(TERMINAL) -e "$(QEMU) -S -s -d in_asm -D $(BINDIR)/q.log -monitor stdio -hda $< -serial null"
		$(V)sleep 2
		$(V)$(TERMINAL) -e "gdb -q -x tools/lab1liuruiyangdebug" 

* 步骤二：在 lab1/tools/ 中新增文件 lab1liuruiyangdebug，其内容如下：  

		file bin/kernel
		target remote :1234
		set architecture i8086

* 步骤三：运行指令 make lab1-liuruiyang-debug，进行实验。可见在 gdb 调试中，访问 \$PC 寄存器时，其值为 0xfff0，说明其并未考虑 CS 寄存器的偏移，因为 gdb 调试设置模拟的CPU架构为 i8086，其为 16 位模式，无法找到正确的地址；而在 qemu 调试中，访问 \$PC 寄存器，发现其按照 CS:IP 计算启动地址，地址为 0xfffffff0，可见此时 CPU 初始时处于 32 位实模式，第一条运行的指令为：  

		(qemu) x $pc
		0xfffffff0:  ljmp   $0xf000,$0xe05b

  在 gdb 调试中输入 nexti（单步一条机器指令，不进入函数），实现长跳转，随后依旧在 qemu 调试中观察，此时 CPU 进入16位实模式，此时指令如下所示：

		(qemu) x /10i $pc
		0x000fe05b:  cmpl   $0x0,%cs:0x6c48
		0x000fe062:  jne    0xfd2e1
		0x000fe066:  xor    %dx,%dx
		0x000fe068:  mov    %dx,%ss
		0x000fe06a:  mov    $0x7000,%esp
		0x000fe070:  mov    $0xf3691,%edx
		0x000fe076:  jmp    0xfd165
		0x000fe079:  push   %ebp
		0x000fe07b:  push   %edi
		0x000fe07d:  push   %esi

<div style="text-align:center;">
	<img src="./实验截图/lab1-练习2-3.png" width="900">
	<img src="./实验截图/lab1-练习2-4.png" width="900">
	<img src="./实验截图/lab1-练习2-5.png" width="900">
</div>

#### 2. 在初始化位置0x7c00设置实地址断点,测试断点正常。
* 步骤四：在 gdb 调试中，输入指令 **b \*0x7c00**，再执行 **continue**，最后输入指令 **x /10i $pc**，其和之前的准备练习中观察的结果相同，说明测试断点正常。

<div style="text-align:center;">
	<img src="./实验截图/lab1-练习2-6.png" width="900">
</div>

#### 3. 从0x7c00开始跟踪代码运行,将单步跟踪反汇编得到的代码与bootasm.S和 bootblock.asm进行比较。
* 步骤五：设置宏指令 showstep，使得 pc += 1，并展示当前 pc 寄存器所指的指令。宏指令设置如下：

		define showstep
		nexti
		x/i $pc
		end  

　　经过观察输出，可以发现代码与 lab1/boot/bootasm.S 中代码一致基本相同。虽然有部分指令经过了编译器的优化，但是整体执行的逻辑和顺序依旧保持不变。

<div style="text-align:center;">
	<img src="./实验截图/lab1-练习2-7.png" width="900">
</div>

#### 4. 自己在内核或Bootloader中寻找代码位置，进行断点测试
* 步骤六：在 kern/debug/kdebug.c 中我选择函数 **print_kerninfo** 作为断点，在 gdb 调试中使用命令 **break print_kerninfo** 和 **continue**，发现 PC 停止在 **0x10084c** 处。随后进行断点测试，测试结果如下图：  

<div style="text-align:center;">
	<img src="./实验截图/lab1-练习2-8.png" width="900">
</div>

---

<br><br><br>

## 练习三：
#### 分析bootloader进入保护模式的过程

* 分析 boot/bootasm.S 的代码解释如下：
	* 第 15 - 23 行代码首先设置中断为禁用，随后设置段寄存器 DS，ES，SS 为0.


			.code16                    # Assemble for 16-bit mode
			    cli                    # Disable interrupts
			    cld                    # String operations increment
			
			    # Set up the important data segment registers (DS, ES, SS).
			    xorw %ax, %ax          # Segment number zero
			    movw %ax, %ds          # -> Data Segment
			    movw %ax, %es          # -> Extra Segment
			    movw %ax, %ss          # -> Stack Segment
			    
	* 第 25 - 43 行代码使能 A20 地址线，先等待 8042 的输入缓存为空，然后将数据写入 8042 的 P2 端口，即向 P2 发送命令。再等待输入缓存空，将 P2 的 A20 位置设置为 1。


			    # Enable A20:
			    #  For backwards compatibility with the earliest PCs, physical
			    #  address line 20 is tied low, so that addresses higher than
			    #  1MB wrap around to zero by default. This code undoes this.
			seta20.1:
			    inb $0x64, %al         # Wait for not busy(8042 input buffer empty)
			    testb $0x2, %al
			    jnz seta20.1
			
			    movb $0xd1, %al        # 0xd1 -> port 0x64
			    outb %al, $0x64        # 0xd1 means: write data to 8042's P2 port
			
			seta20.2:
			    inb $0x64, %al         # Wait for not busy(8042 input buffer empty)
			    testb $0x2, %al
			    jnz seta20.2
			
			    movb $0xdf, %al        # 0xdf -> port 0x60
			    outb %al, $0x60        # 0xdf = 11011111, means set P2's A20 bit(the 1 bit) to 1

	* 第 49 行：读取 GDT 表。GDT 表是静态设定好的，在汇编代码的最后先通过 gdt 标签定义了一个段描述符，之后通过 gdtdesc 定义了一个段表。

			    # Switch from real to protected mode, using a bootstrap GDT
			    # and segment translation that makes virtual addresses
			    # identical to physical addresses, so that the
			    # effective memory map does not change during the switch.
			    lgdt gdtdesc
	
	* 第 50 - 56 行：将 CR0 寄存器的 PE 位置为使能，跳转到 32 位地址，完成到保护模式的转换。
				
				movl %cr0, %eax
				orl $CR0_PE_ON, %eax
				movl %eax, %cr0
			
				# Jump to next instruction, but in 32-bit code segment.
				# Switches processor into 32-bit mode.
				ljmp $PROT_MODE_CSEG, $protcseg
				
	* 第 61 ～ 行：设置保护模式数据段寄存器，设置堆栈指针，堆栈区域从 0 ～ 0x7c00，然后调用bootmain函数。

				.code32                # Assemble for 32-bit mode
				protcseg:
				    # Set up the protected-mode data segment registers
				    movw $PROT_MODE_DSEG, %ax     # Our data segment selector
				    movw %ax, %ds      # -> DS: Data Segment
				    movw %ax, %es      # -> ES: Extra Segment
				    movw %ax, %fs      # -> FS
				    movw %ax, %gs      # -> GS
				    movw %ax, %ss      # -> SS: Stack Segment
				
				    # Set up the stack pointer and call into C. The stack region is from 0--start(0x7c00)
				    movl $0x0, %ebp
				    movl $start, %esp
				    call bootmain
				
				    # If bootmain returns (it shouldn't), loop.
				spin:
				    jmp spin
<br>	
			    
#### 为何开启A20，以及如何开启A20？   

　　在 i8086 时代，CPU 的数据总线是 16bit，地址总线是 20bit，寄存器是 16bit，因此 CPU 只能访问 1MB 以内的空间。因为数据总线和寄存器只有 16bit，如果需要获取 20bit 的数据, 我们需要做一些额外的操作，比如移位。实际上，CPU 是通过对 segment (每个 segment 大小恒定为 64K ) 进行移位后和 offset 一起组成了一个 20bit 的地址，这个地址就是实模式下访问内存的地址：
		
		address = segment << 4 | offset

　　理论上，20bit 的地址可以访问 1MB 的内存空间( 0x00000 - ( 2^20 - 1 = 0xFFFFF ))。但在实模式下, 这 20bit 的地址理论上能访问从 0x00000 - ( 0xFFFF0 + 0xFFFF = 0x10FFEF ) 的内存空间。也就是说，理论上我们可以访问超过 1MB 的内存空间，但越过 0xFFFFF 后，地址又会回到 0x00000。  
　　上面这个特征在 i8086 中是没有任何问题的，因为它最多只能访问1MB的内存空间，但到了i80286/i80386 后，CPU 有了更宽的地址总线，数据总线和寄存器后，这就会出现一个问题：在实模式下, 我们可以访问超过 1MB 的空间，但我们只希望访问 1MB 以内的内存空间，以实现向后兼容。为了解决这个问题，CPU中添加了一个可控制 A20 地址线的模块，通过这个模块，我们在实模式下将第 20bit 的地址线限制为 0，这样CPU就不能访问超过 1MB 的空间了。进入保护模式后，我们再通过这个模块解除对 A20 地址线的限制，这样我们就能访问超过 1MB 的内存空间了。  
　　默认情况下，A20 地址线是关闭的( 20bit 以上的地址线限制为 0)，因此在进入保护模式(需要访问超过 1MB 的内存空间)前，我们需要开启 A20 地址线( 20bit 以上的地址线可为 0 或者 1 )。  
　　根据上述第 25 - 43 行代码即可实现 A20 的开启。

<br>	

#### 如何初始化GDT表？  

　　根据 boot/bootasm.S 和 boot/asm.h 代码所示，这里所有 GDT 表项(除了空段)初始化为全段，此时段偏移量 EIP 等于物理地址。


		# Bootstrap GDT
		.p2align 2             # force 4 byte alignment
		gdt:
		    SEG_NULLASM        # null seg
		    SEG_ASM(STA_X|STA_R, 0x0, 0xffffffff)     # code seg for bootloader and kernel
		    SEG_ASM(STA_W, 0x0, 0xffffffff)           # data seg for bootloader and kernel
		
		gdtdesc:
		    .word 0x17         # sizeof(gdt) - 1
		    .long gdt          # address gdt
		
		...
		
		/* Normal segment */
		#define SEG_NULLASM
		    .word 0, 0;
		    .byte 0, 0, 0, 0
		
		#define SEG_ASM(type,base,lim) 
			.word (((lim) >> 12) & 0xffff), ((base) & 0xffff);  
			.byte (((base) >> 16) & 0xff), (0x90 | (type)),(0xC0 | (((lim) >> 28) & 0xf)), (((base) >> 24) & 0xff)
　　
<br><br>

#### 如何使能和进入保护模式？  

　　使能是将 CR0 寄存器的 bit 0 位（PE）设置为 CR0\_PE\_ON（0x1），即 CR0 中的数字为 1。在开启 A20 和初始化 GDT 后，根据 PROT\_MODE\_CSEG（kernel 的代码段选择子），采用 ljmp 长跳转指令进行跳转，实现保护模式的进入。
　　
#### 备注：x86实模式和保护模式的 CS:IP 寻址方式概述

　　CS 寄存器分为可见的选择子 selector 区域（16位）和不可见的基址 base address 区域（32位）。 实际上，不可见区域如果不存在，整个体系也能正常工作，不可见区域仅仅是一个缓存。

　　在 16 位实模式下，线性地址可寻址空间为 1M，寻址方式为 base address + eip，其中 base address 在一般情况下等于 selector << 4，但是在刚刚开机上电的时候这种关系不成立，此时 base address = 0xFFFF0000，但是 selector = 0xF000，再加上 eip = 0x0000FFF0，最终形成了 0xFFFFFFF0 的最初地址。而之后进行了跳转指令之后，base address 缓存得到更新，重新计算为 0x000F0000，之后的寻址便从 0x000FXXXX 开始了。

　　在32位保护模式下，线性地址可寻址空间为 4G，寻址方式为 base address + eip，其中 base address 总是等于 **selector 中的 index 域指向的 GDT 表项的偏移基址**。
　　
##### 段选择子

　　在实模式下, 逻辑地址由段选择子和段选择子偏移量组成. 其中, 段选择子16bit, 段选择子偏移量是32bit. 下面是段选择子的示意图:
<div style="text-align:center;">
	<img src="./实验截图/lab1-练习3-1.png" width="900">
</div>

* 在段选择子中，其中的 INDEX[15:3] 是 GDT 的索引。
* TI[2:2] 用于选择表格的类型，1 是 LDT，0 是 GDT。
* RPL[1:0] 用于选择请求者的特权级，00 最高，11 最低。

##### GDT的访问

<div style="text-align:center;">
	<img src="./实验截图/lab1-练习3-2.png" width="900">
</div>

* 根据 CPU 给的逻辑地址分离出段选择子。
* 利用段选择子查找到对应的段描述符。
* 将段描述符里的 Base Address 和 EIP 相加而得到线性地址。

---

<br><br><br>

## 练习四：