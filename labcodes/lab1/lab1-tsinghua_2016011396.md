# Lab1实验报告
计61 柳瑞阳 2016011396

## 练习一：

#### 操作系统镜像文件ucore.img是如何一步一步生成的？

答：运行命令行指令 **make V=**，观察输出可见编译过程如下：  

* 运行编译器对操作系统内核代码进行编译生成重定向执行文件（ **.o** 文件）。需要编译的文件包括：
	* kern/init 文件下的 init.c；
	* kern/libs 文件下的 readline.c，stdio.c；
	* kern/debug 文件下的 kmonitor.c，panic.c；
	* kern/driver 文件下的 clock.c，console.c，intr.c，picirq.c；
	* kern/trap 文件下的 trap.c，trapentry.S，vectors.S；
	* kern/mm 文件下的 pmm.c；
	* libs/ 文件下的 printfmt.c，string.c

　　代码举例如下：

		+ cc kern/debug/panic.c
		i386-elf-gcc -Ikern/debug/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/debug/panic.c -o obj/kern/debug/panic.o

　　其中使用参数意义如下：

　　　　-nostdinc：使编译器不再系统缺省的目录里查找头文件，一般和-I一起使用，明确限定头文件的位置。    
　　　　-fno-builtin：不使用C语言的内建函数而使用自己定义的，例如printf。  
　　　　-Wall：编译时显示所有的警告，由于检查程序错误。  
　　　　-ggdb：此选项将尽可能的生成gdb可以使用的调试信息。  
　　　　-m32：交叉编译选项，生成32位（x86）代码。  
　　　　-gstabs：此选项以stabs格式生成调试信息，但是不包括gdb调试信息。  
　　　　-fno-stack-protector：不使用栈完整性确认（金丝雀）机制，在某些默认打开stack protector的编译器上必须使用，这是因为该机制会调用__stack_chk_fail标准库函数，而在编译操作系统内核时我们不能使用标准库。

* 运行链接器链接重定向文件，将上述生成的 .o 文件链接为 ELF 格式可执行文件 /bin/kernel：

		+ ld bin/kernel
		i386-elf-ld -m elf_i386 -nostdlib -T tools/kernel.ld -o bin/kernel  obj/kern/init/init.o obj/kern/libs/readline.o obj/kern/libs/stdio.o obj/kern/debug/kdebug.o obj/kern/debug/kmonitor.o obj/kern/debug/panic.o obj/kern/driver/clock.o obj/kern/driver/console.o obj/kern/driver/intr.o obj/kern/driver/picirq.o obj/kern/trap/trap.o obj/kern/trap/trapentry.o obj/kern/trap/vectors.o obj/kern/mm/pmm.o  obj/libs/printfmt.o obj/libs/string.o

　　其中使用参数意义如下：  

　　　　-m elf\_i386：交叉编译生成i386平台的代码。  
　　　　-nostdlib：不链接C标准库，防止C标准库使用自带的init函数代替入口函数。  
　　　　-T tools/kernel.ld：使用自编的链接脚本进行代码段、数据段空间的分配，并把ELF可执行文件的入口点设置为函数kern_init。  

* 运行编译器对 Bootloader 代码进行编译生成重定向执行文件（ **.o** 文件）。需要编译的文件包括：
	* boot 文件下的 bootasm.S；
	* boot 文件下的 bootmain.c；

　　代码举例如下：

		+ cc boot/bootasm.S
		i386-elf-gcc -Iboot/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Os -nostdinc -c boot/bootasm.S -o obj/boot/bootasm.o

　　其中使用参数意义同上。  

* 运行编译器和链接器对硬盘主引导扇区进行编译和链接，生成 bin/sign。  

　　代码举例如下：

		+ cc tools/sign.c
		gcc -Itools/ -g -Wall -O2 -c tools/sign.c -o obj/sign/tools/sign.o
		gcc -g -Wall -O2 obj/sign/tools/sign.o -o bin/sign

　　其中使用参数意义如下：  

　　　　-g 保留代码的文字信息，便于调试。  
　　　　-O2：优化优先级选项。  
　　　　-Wall：编译时显示所有的警告，由于检查程序错误。  

* 运行链接器链接Bootloader，生成 bin/bootblock。  

　　代码举例如下：

	+ ld bin/bootblock
	i386-elf-ld -m elf_i386 -nostdlib -N -e start -Ttext 0x7C00 obj/boot/bootasm.o obj/boot/bootmain.o -o obj/bootblock.o

　　其中使用参数意义如下：  
 
　　　　-N：将代码区和数据区设置为可读可写，不对数据区进行页对齐，不链接标准库。  
　　　　-e start：设置入口函数为start。  
　　　　-Ttext 0x7C00：设定代码段的虚拟内存地址为0x7C00，即主引导扇区被读取到内存的地址。这个地址实际是BIOS自动拷贝到的，这里再次进行设定应该是程序中直接寻址需要。  

* 运行 OBJDUMP 和 OBJCOPY 实用工具，导出 Bootloader 的代码段。

　　输出结果举例如下：

	'obj/bootblock.out' size: 500 bytes

* 使用 sign 程序，处理 Bootloader 代码，生成 512 字节的 MBR 扇区镜像。

　　输出结果举例如下：

	build 512 bytes boot sector: 'bin/bootblock' success!

* 运行dd程序，创建ucore.img硬盘镜像。  

　　输出结果举例如下：

	dd if=/dev/zero of=bin/ucore.img count=10000
	10000+0 records in
	10000+0 records out
	5120000 bytes transferred in 0.064835 secs (78969896 bytes/sec)
	dd if=bin/bootblock of=bin/ucore.img conv=notrunc
	1+0 records in
	1+0 records out
	512 bytes transferred in 0.000028 secs (18354561 bytes/sec)
	dd if=bin/kernel of=bin/ucore.img seek=1 conv=notrunc
	154+1 records in
	154+1 records out

　　其中使用参数意义如下：  
 
　　　　if：输入文件。  
　　　　of：输出文件。  
　　　　count：拷贝block的个数。  
　　　　seek：数据拷贝起始block寻址。  
　　　　conv=notrunc：当dd到一个比源文件大的目标文件时，不缩小目标文件。  

　　至此 ucore.img 文件生成完成。

---


#### 一个被系统认为是符合规范的硬盘主引导扇区的特征是什么？

答：通过阅读 **ucore_os_lab/labcodes/lab1/tools/sign.c** 的代码可发现，符合规范的硬盘主引导扇区的特征包括 3 个方面：  

* st.st_size（文件内容） 不能超过 510 字节，即启动代码和硬盘分区表加起来不能超过 510 字节。   
* 主引导扇区大小为 512 字节。   
* 结束标志字，即最后两个字节为 0x55 和 0xAA。

---

<br><br><br>


## 练习二：

#### 准备工作：模仿学堂在线视频进行操作
* 步骤一：在 lab1/Makefile 中新增代码：  

		lab1-mon: $(UCOREIMG)
			$(V)$(TERMINAL) -e "$(QEMU) -S -s -d in_asm -D $(BINDIR)/q.log -monitor stdio -hda $< -serial null"
			$(V)sleep 2
			$(V)$(TERMINAL) -e "gdb -q -x tools/lab1init"
		
	其中修改的第一条指令含义为，新启动一个 gnome 终端并运行 debug 状态的 qemu，并将打印的汇编代码输出到 q.log 文件中。第三条指令含义为初始化 gdb 调试指令。  

* 步骤二：在 lab1/tools/ 中新增文件 lab1init，其内容如下：  

		file bin/kernel
		target remote :1234
		set architecture i8086
		b *0x7c00
		continue
		x /2i $pc  

　　含义为：首先加载 kernel，然后使得 qemu 和 gdb 之间使用网络端口 1234 进行通讯，刚开始 BIOS 进入 8086 的 16 位实模式方式。在地址为 0x7c00（Bootloader第一条指令）处设置断点，然后使得程序运行，然后显示出 PC 寄存器（EIP 指令指针寄存器）处开始的两条指令。

* 步骤三：运行指令 make lab1-mon，观察输出结果；并输入指令 x /10i $pc，观察输出结果。并检验与 lab1/boot/bootasm.S 中代码一致。

<div style="text-align:center;">
	<img src="./实验截图/lab1-练习2-1.png" width="900">
	<img src="./实验截图/lab1-练习2-2.png" width="900">
</div>

---

#### 1. 从CPU加电后的第一条指令开始，单步跟踪BIOS的运行。
* 步骤一：在 lab1/Makefile 中新增代码：  

		lab1-liuruiyang-debug: $(UCOREIMG)
		$(V)$(TERMINAL) -e "$(QEMU) -S -s -d in_asm -D $(BINDIR)/q.log -monitor stdio -hda $< -serial null"
		$(V)sleep 2
		$(V)$(TERMINAL) -e "gdb -q -x tools/lab1liuruiyangdebug" 

* 步骤二：在 lab1/tools/ 中新增文件 lab1liuruiyangdebug，其内容如下：  

		file bin/kernel
		target remote :1234
		set architecture i8086

* 步骤三：运行指令 make lab1-liuruiyang-debug，进行实验。可见在 gdb 调试中，访问 \$PC 寄存器时，其值为 0xfff0，说明其并未考虑 CS 寄存器的偏移，因为 gdb 调试设置模拟的CPU架构为 i8086，其为 16 位模式，无法找到正确的地址；而在 qemu 调试中，访问 \$PC 寄存器，发现其按照 CS:IP 计算启动地址，地址为 0xfffffff0，可见此时 CPU 初始时处于 32 位实模式，第一条运行的指令为：  

		(qemu) x $pc
		0xfffffff0:  ljmp   $0xf000,$0xe05b

  在 gdb 调试中输入 nexti（单步一条机器指令，不进入函数），实现长跳转，随后依旧在 qemu 调试中观察，此时 CPU 进入16位实模式，此时指令如下所示：

		(qemu) x /10i $pc
		0x000fe05b:  cmpl   $0x0,%cs:0x6c48
		0x000fe062:  jne    0xfd2e1
		0x000fe066:  xor    %dx,%dx
		0x000fe068:  mov    %dx,%ss
		0x000fe06a:  mov    $0x7000,%esp
		0x000fe070:  mov    $0xf3691,%edx
		0x000fe076:  jmp    0xfd165
		0x000fe079:  push   %ebp
		0x000fe07b:  push   %edi
		0x000fe07d:  push   %esi

<div style="text-align:center;">
	<img src="./实验截图/lab1-练习2-3.png" width="900">
	<img src="./实验截图/lab1-练习2-4.png" width="900">
	<img src="./实验截图/lab1-练习2-5.png" width="900">
</div>

#### 2. 在初始化位置0x7c00设置实地址断点,测试断点正常。
* 步骤四：在 gdb 调试中，输入指令 **b \*0x7c00**，再执行 **continue**，最后输入指令 **x /10i $pc**，其和之前的准备练习中观察的结果相同，说明测试断点正常。

<div style="text-align:center;">
	<img src="./实验截图/lab1-练习2-6.png" width="900">
</div>

#### 3. 从0x7c00开始跟踪代码运行,将单步跟踪反汇编得到的代码与bootasm.S和 bootblock.asm进行比较。
* 步骤五：设置宏指令 showstep，使得 pc += 1，并展示当前 pc 寄存器所指的指令。宏指令设置如下：

		define showstep
		nexti
		x/i $pc
		end  

　　经过观察输出，可以发现代码与 lab1/boot/bootasm.S 中代码一致基本相同。虽然有部分指令经过了编译器的优化，但是整体执行的逻辑和顺序依旧保持不变。

<div style="text-align:center;">
	<img src="./实验截图/lab1-练习2-7.png" width="900">
</div>

#### 4. 自己在内核或Bootloader中寻找代码位置，进行断点测试
* 步骤六：在 kern/debug/kdebug.c 中我选择函数 **print_kerninfo** 作为断点，在 gdb 调试中使用命令 **break print_kerninfo** 和 **continue**，发现 PC 停止在 **0x10084c** 处。随后进行断点测试，测试结果如下图：  

<div style="text-align:center;">
	<img src="./实验截图/lab1-练习2-8.png" width="900">
</div>

---

<br><br><br>

## 练习三：
#### 分析bootloader进入保护模式的过程

* 分析 boot/bootasm.S 的代码解释如下：
	* 第 15 - 23 行代码首先设置中断为禁用，随后设置段寄存器 DS，ES，SS 为0.


			.code16                    # Assemble for 16-bit mode
			    cli                    # Disable interrupts
			    cld                    # String operations increment
			
			    # Set up the important data segment registers (DS, ES, SS).
			    xorw %ax, %ax          # Segment number zero
			    movw %ax, %ds          # -> Data Segment
			    movw %ax, %es          # -> Extra Segment
			    movw %ax, %ss          # -> Stack Segment
			    
	* 第 25 - 43 行代码使能 A20 地址线，先等待 8042 的输入缓存为空，然后将数据写入 8042 的 P2 端口，即向 P2 发送命令。再等待输入缓存空，将 P2 的 A20 位置设置为 1。


			    # Enable A20:
			    #  For backwards compatibility with the earliest PCs, physical
			    #  address line 20 is tied low, so that addresses higher than
			    #  1MB wrap around to zero by default. This code undoes this.
			seta20.1:
			    inb $0x64, %al         # Wait for not busy(8042 input buffer empty)
			    testb $0x2, %al
			    jnz seta20.1
			
			    movb $0xd1, %al        # 0xd1 -> port 0x64
			    outb %al, $0x64        # 0xd1 means: write data to 8042's P2 port
			
			seta20.2:
			    inb $0x64, %al         # Wait for not busy(8042 input buffer empty)
			    testb $0x2, %al
			    jnz seta20.2
			
			    movb $0xdf, %al        # 0xdf -> port 0x60
			    outb %al, $0x60        # 0xdf = 11011111, means set P2's A20 bit(the 1 bit) to 1

	* 第 49 行：是把 gdtdesc 这个标识符的值送入全局映射描述符表寄存器 GDTR 中。这条指令的功能就是把关于 GDT 表的一些重要信息存放到 CPU 的 GDTR 寄存器中，其中包括 GDT 表的内存起始地址，以及 GDT 表的长度。这个寄存器由 48 位组成，其中低 16 位表示该表长度，高 32 位表该表在内存中的起始地址。所以 gdtdesc 是一个标识符，标识着一个内存地址。从这个内存地址开始之后的 6 个字节中存放着 GDT 表的长度和起始地址。

			    # Switch from real to protected mode, using a bootstrap GDT
			    # and segment translation that makes virtual addresses
			    # identical to physical addresses, so that the
			    # effective memory map does not change during the switch.
			    lgdt gdtdesc
	
	* 第 50 - 56 行：将 CR0 寄存器的 PE 位置为使能，跳转到 32 位地址，完成到保护模式的转换。
				
				movl %cr0, %eax
				orl $CR0_PE_ON, %eax
				movl %eax, %cr0
			
				# Jump to next instruction, but in 32-bit code segment.
				# Switches processor into 32-bit mode.
				ljmp $PROT_MODE_CSEG, $protcseg
				
	* 第 61 ～ 行：设置保护模式数据段寄存器，设置堆栈指针，堆栈区域从 0 ～ 0x7c00，然后调用bootmain函数。

				.code32                # Assemble for 32-bit mode
				protcseg:
				    # Set up the protected-mode data segment registers
				    movw $PROT_MODE_DSEG, %ax     # Our data segment selector
				    movw %ax, %ds      # -> DS: Data Segment
				    movw %ax, %es      # -> ES: Extra Segment
				    movw %ax, %fs      # -> FS
				    movw %ax, %gs      # -> GS
				    movw %ax, %ss      # -> SS: Stack Segment
				
				    # Set up the stack pointer and call into C. The stack region is from 0--start(0x7c00)
				    movl $0x0, %ebp
				    movl $start, %esp
				    call bootmain
				
				    # If bootmain returns (it shouldn't), loop.
				spin:
				    jmp spin
<br>	
			    
#### 为何开启A20，以及如何开启A20？   

　　在 i8086 时代，CPU 的数据总线是 16bit，地址总线是 20bit，寄存器是 16bit，因此 CPU 只能访问 1MB 以内的空间。因为数据总线和寄存器只有 16bit，如果需要获取 20bit 的数据, 我们需要做一些额外的操作，比如移位。实际上，CPU 是通过对 segment (每个 segment 大小恒定为 64K ) 进行移位后和 offset 一起组成了一个 20bit 的地址，这个地址就是实模式下访问内存的地址：
		
		address = segment << 4 | offset

　　理论上，20bit 的地址可以访问 1MB 的内存空间( 0x00000 - ( 2^20 - 1 = 0xFFFFF ))。但在实模式下, 这 20bit 的地址理论上能访问从 0x00000 - ( 0xFFFF0 + 0xFFFF = 0x10FFEF ) 的内存空间。也就是说，理论上我们可以访问超过 1MB 的内存空间，但越过 0xFFFFF 后，地址又会回到 0x00000。  
　　上面这个特征在 i8086 中是没有任何问题的，因为它最多只能访问1MB的内存空间，但到了i80286/i80386 后，CPU 有了更宽的地址总线，数据总线和寄存器后，这就会出现一个问题：在实模式下, 我们可以访问超过 1MB 的空间，但我们只希望访问 1MB 以内的内存空间，以实现向后兼容。为了解决这个问题，CPU中添加了一个可控制 A20 地址线的模块，通过这个模块，我们在实模式下将第 20bit 的地址线限制为 0，这样CPU就不能访问超过 1MB 的空间了。进入保护模式后，我们再通过这个模块解除对 A20 地址线的限制，这样我们就能访问超过 1MB 的内存空间了。  
　　默认情况下，A20 地址线是关闭的( 20bit 以上的地址线限制为 0)，因此在进入保护模式(需要访问超过 1MB 的内存空间)前，我们需要开启 A20 地址线( 20bit 以上的地址线可为 0 或者 1 )。  
　　根据上述第 25 - 43 行代码即可实现 A20 的开启。

<br>	

#### 如何初始化GDT表？  

　　根据 boot/bootasm.S 和 boot/asm.h 代码所示，这里所有 GDT 表项(除了空段)初始化为全段，此时段偏移量 EIP 等于物理地址。这里 gdt 分别代表三个段，null seg，code seg，data seg。由于 xv6 其实并没有使用分段机制，也就是说数据和代码都是写在一起的，所以数据段和代码段的起始地址都是 0x0，大小都是 0xffffffff = 4GB。然后在 gdtdesc 处就要存放这个 GDT 表的信息了，其中 0x17 是这个表的大小 -1 = 0x17 = 23，紧接着就是这个表的起始地址 gdt。


		# Bootstrap GDT
		.p2align 2             # force 4 byte alignment
		gdt:
		    SEG_NULLASM        # null seg
		    SEG_ASM(STA_X|STA_R, 0x0, 0xffffffff)     # code seg for bootloader and kernel
		    SEG_ASM(STA_W, 0x0, 0xffffffff)           # data seg for bootloader and kernel
		
		gdtdesc:
		    .word 0x17         # sizeof(gdt) - 1
		    .long gdt          # address gdt
		
		...
		
		/* Normal segment */
		#define SEG_NULLASM
		    .word 0, 0;
		    .byte 0, 0, 0, 0
		
		#define SEG_ASM(type,base,lim) 
			.word (((lim) >> 12) & 0xffff), ((base) & 0xffff);  
			.byte (((base) >> 16) & 0xff), (0x90 | (type)),(0xC0 | (((lim) >> 28) & 0xf)), (((base) >> 24) & 0xff)
　　
<br><br>

#### 如何使能和进入保护模式？  

　　使能是将 CR0 寄存器的 bit 0 位（PE）设置为 CR0\_PE\_ON（0x1），即 CR0 中的数字为 1。在开启 A20 和初始化 GDT 后，根据 PROT\_MODE\_CSEG（kernel 的代码段选择子），采用 ljmp 长跳转指令进行跳转，实现保护模式的进入。
　　
#### 备注：x86实模式和保护模式的 CS:IP 寻址方式概述

　　CS 寄存器分为可见的选择子 selector 区域（16位）和不可见的基址 base address 区域（32位）。 实际上，不可见区域如果不存在，整个体系也能正常工作，不可见区域仅仅是一个缓存。

　　在 16 位实模式下，线性地址可寻址空间为 1M，寻址方式为 base address + eip，其中 base address 在一般情况下等于 selector << 4，但是在刚刚开机上电的时候这种关系不成立，此时 base address = 0xFFFF0000，但是 selector = 0xF000，再加上 eip = 0x0000FFF0，最终形成了 0xFFFFFFF0 的最初地址。而之后进行了跳转指令之后，base address 缓存得到更新，重新计算为 0x000F0000，之后的寻址便从 0x000FXXXX 开始了。

　　在32位保护模式下，线性地址可寻址空间为 4G，寻址方式为 base address + eip，其中 base address 总是等于 **selector 中的 index 域指向的 GDT 表项的偏移基址**。
　　
##### 段选择子

　　在实模式下, 逻辑地址由段选择子和段选择子偏移量组成. 其中, 段选择子16bit, 段选择子偏移量是32bit. 下面是段选择子的示意图:
<div style="text-align:center;">
	<img src="./实验截图/lab1-练习3-1.png" width="900">
</div>

* 在段选择子中，其中的 INDEX[15:3] 是 GDT 的索引。
* TI[2:2] 用于选择表格的类型，1 是 LDT，0 是 GDT。
* RPL[1:0] 用于选择请求者的特权级，00 最高，11 最低。

##### GDT的访问

<div style="text-align:center;">
	<img src="./实验截图/lab1-练习3-2.png" width="900">
</div>

* 根据 CPU 给的逻辑地址分离出段选择子。
* 利用段选择子查找到对应的段描述符。
* 将段描述符里的 Base Address 和 EIP 相加而得到线性地址。

---

<br><br><br>

## 练习四：

#### bootloader如何读取硬盘扇区的？

	static void
	readseg(uintptr_t va, uint32_t count, uint32_t offset) {
	    uintptr_t end_va = va + count;
	
	    // round down to sector boundary
	    va -= offset % SECTSIZE;
	
	    // translate from bytes to sectors; kernel starts at sector 1
	    uint32_t secno = (offset / SECTSIZE) + 1;
	
	    // If this is too slow, we could read lots of sectors at a time.
	    // We'd write more to memory than asked, but it doesn't matter --
	    // we load in increasing order.
	    for (; va < end_va; va += SECTSIZE, secno ++) {
	        readsect((void *)va, secno);
	    }
	}

　　在执行完 bootasm.S 后，此时系统从实模式进入了保护模式，然后执行 bootasm.c，开始加载 OS。bootasm.c 完成的任务是引导来自第一个 IDE 硬盘的 ELF 内核映像，在保护模式的内核态读取和拷贝内核的 ELF 文件。所以必须要对硬盘进行访问。第一个 IDE 硬盘的 I/O 地址为 **0x1F0 ~ 0x1F7**。详见 bootasm.c 的 readsect 函数，其执行步骤如下：  

* 循环访问端口 0x1F7，检查磁盘是否处于空闲状态，一直等待磁盘准备好为止。
* 向端口 0x1F2 写入要读取的扇区个数，本实验为读取 1 个扇区。
* 向端口 0x1F3 ～ 0x1F6 写入要读区的扇区编号信息。
* 向端口 0x1F7 写入 0x20 指令，代表读取扇区。
* 循环访问端口 0x1F7，检查磁盘是否处于空闲状态，一直等待磁盘读取完成为止。
* 通过 insl 指令读取一个扇区的内容并保存到指定的虚拟内存中去。（insl，这个函数包含3个输入参数，port代表端口号，addr代表这个扇区存放在主存中的起始地址，cnt则代表读取的次数）

<br>

#### bootloader是如何加载ELF格式的OS？

	// read 1st page off disk
	readseg((uint32_t) ELFHDR, SECTSIZE*8, 0);

　　bootmain 函数首先调用 **readseg((uintptr_t)ELFHDR, SECTSIZE * 8, 0);** 这里调用了函数 readseg（ readseg(uintptr_t va, uint32_t count, uint32_t offset) ），其功能是把距离内核起始地址 offset 个偏移量存储单元作为起始，将它和它之后的 count 字节的数据读出送入以 va 为起始地址的内存虚拟地址处。所以这条指令是把内核的第一个页 ( 4MB = 4096 = SECTSIZE * 8 = 512 * 8 ) 的内容读取的内存地址 ELFHDR ( 0x10000 ) 处。其实完成这些后相当于把操作系统映像文件的 ELF 头部读取出来放入内存中。  
　　读取完这个内核的 ELF 头部信息后，需要对这个 ELF 头部信息进行验证，并且也需要通过它获取一些重要信息。

	// is this a valid ELF?
    if (ELFHDR->e_magic != ELF_MAGIC) {
        goto bad;
    }

　　ELF 头部信息 ELFHDR 的 e\_magic 字段是整个头部信息的开端。并且如果这个文件是格式是 ELF 格式的话，文件的 ELFHDR->e\_magic 域应该等于 ELF\_MAGIC 的，所以这条语句就是判断这个输入文件是否是合法的 ELF 可执行文件。

	// load each program segment (ignores ph flags)
	ph = (struct proghdr *)((uintptr_t)ELFHDR + ELFHDR->e_phoff);

　　ELFHDR 中一定包含 Program Header Table。这个表格存放着程序中所有段的信息。通过这个表我们才能找到要执行的代码段，数据段等等信息。为了获得这个表，采取这条指令。首先 ELFHDR 是表头起址，而 e\_phoff 字段代表 Program Header Table 距离表头的偏移量。所以 ph 可以被指定为Program Header Table 的表头。

	eph = ph + ELFHDR->e_phnum;

　　由于 e\_phnum 中存放的是 Program Header Table 表中表项的个数，即段的个数。用表头加表项的个数，所以这步操作是把 eph 指向该表末尾。

	for (; ph < eph; ph ++) {
	    readseg(ph->p_va & 0xFFFFFF, ph->p_memsz, ph->p_offset);
	}

　　这个 for 循环就是在把操作系统内核的各个段从外存读入内存中。ph->p\_va 指的是这个段在内存中的虚拟地址。ph-> p\_offset 字段指的是这一段的开头相对于这个 ELF 文件的开头的偏移量。ph->p\_filesz 字段指的是这个段在 ELF 文件中的大小。ph->p\_memsz 则指的是这个段被实际装入内存后的大小。通常来说 ph->p\_memsz 一定大于等于 ph->p\_filesz，因为段在文件中时许多未定义的变量并没有分配空间给它们。

	// call the entry point from the ELF header
	// note: does not return
	((void (*)(void))(ELFHDR->e_entry & 0xFFFFFF))();

　　ELFHDR->e_entry 字段指向的是这个文件的执行入口地址。相当于开始运行这个文件，即内核文件。   
　　自此就把控制权从 bootloader 转交给了操作系统的内核。  

（参考 https://https://www.cnblogs.com/fatsheep9146）

---

<br><br><br>

## 练习五：

#### 任务要求

　　在 lab1 中完成 kdebug.c 中函数 print\_stackframe 的实现，可以通过函数 print\_stackframe 来跟踪函数调用堆栈中记录的返回地址。

#### 函数栈基本知识

　　首先认识函数栈的基本知识：  

* ebp 基址指针寄存器。 
* esp 堆栈指针寄存器(指向栈顶) 。 
* ebp 寄存器中存储着栈中的一个地址（原 ebp 入栈后的栈顶），以地址为基准，向上（栈底方向）能获取返回地址、参数值，向下（栈顶方向）能获取函数局部变量值，而该地址处又存储着上一层函数调用时的 ebp 值。  

　　举一个实际的例子查看 %ebp 与 %esp 两个寄存器如何构建出完整的函数栈，最后的 leave 等同于 **movl %ebp, %esp** 和 **popl %ebp** 两条指令
<div style="text-align:center;">
	<img src="./实验截图/lab1-练习5-1.png" width="900">
	<img src="./实验截图/lab1-练习5-2.gif" width="900">
</div>

（参考借鉴 https://www.jianshu.com/p/969e1bdcb471 ）  
　　
#### 输出分析　

　　阅读实验样例输出可发现每两行的含义为：  

* ebp：栈帧基指针寄存器中的值
* eip：存储 CPU 要读取指令的地址，CPU 通过 eip 寄存器读取即将要执行的指令
* args：调用该函数时传入的参数值
* kernel/XXX/XXX.c:line：PC 所在位置对应的源程序代码位置和行数，即该帧进行函数调用时候的程序位置。

<div style="text-align:center;">
	<img src="./实验截图/lab1-练习5-3.png" width="900">
</div>

#### 代码实现

　　代码实现思路同前述讲解，首先读取 ebp 和 eip 的值，然后通过 for 循环追踪函数调用栈。首先输出 ebp 和 eip 的值，随后获取函数栈中参数列表的地址，再通过一个新的 for 循环，以此输出参数。调用 print_debuginfo 函数输出当前的调用的函数名称和所在行数信息，即第二行信息。最后更新 ebp 和 eip 即可。

<div style="text-align:center;">
	<img src="./实验截图/lab1-练习5-4.png" width="900">
</div>

　　在实验的第一次我未添加 **ebp != 0** 的判断条件，导致输出结果如下图，与实验要求不符合。当对比 lab1_result 后发现添加其即可实现实验要求。可见部分地址参数和实验展示结果有所不同，是因为我在 MAC 下进行的编译链接，但是通过函数调用代码的名称和行数可见，练习五实现成功。
　　
<div style="text-align:center;">
	<img src="./实验截图/lab1-练习5-5.png" width="900"><br>
	(未添加 ebp != 0 导致错误）<br><br>
	<img src="./实验截图/lab1-练习5-6.png" width="900"><br>
	(添加 ebp != 0 后正确)
</div>

---

<br><br><br>

## 练习六：


### 参考资料：  

* lab1_result  
* https://https://www.cnblogs.com/fatsheep9146  
* https://blog.csdn.net/qq_31481187/article/details/63251420
* https://www.jianshu.com/p/969e1bdcb471  
* 黄家辉学长资料：lab1-tsinghua_huangjh14.md